---
output: hugodown::hugo_document

slug: dbplyr-2-0-0
title: dbplyr 2.0.0
date: 2020-10-12
author: Hadley Wickham
description: >
    dbplyr 2.0.0 brings dplyr 1.0.0 compatibility, numeric improvements
    to SQL translation (including new Amazon Redshift and SAP HANA 
    backends), and an improved system for extending dbplyr to work with
    other databases.
    
photo:
  url: https://unsplash.com/photos/r2A6WYI8YIg
  author: Shawn Ang

categories: [package] 
tags: [dbplyr, dplyr]
---

```{r, include = FALSE}
library(dplyr, warn.conflicts = FALSE)
```

We're pleased to announce the release of [dbplyr](https://dbplyr.tidyverse.org/) 2.0.0.
dbplyr is a database backend for [dplyr](https://dplyr.tidyverse.org/) that allows you to use a remote database as if it was a collection of local data frames: you write ordinary dplyr code and dbplyr translates it to SQL for you.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("dbplyr")
```

This blog post covers the major improvements in this version:

-   dplyr 1.0.0 compatibility so you can now use `across()`, `relocate()`, `rename_with()`, and more.

-   The major improvements to SQL translation.

-   A snazzy new logo from [Allison Horst](https://www.allisonhorst.com).

-   An improved extension system.

Please see the [release notes](%7B%20github_release%20%7D) for a full list of changes.

```{r setup, message = FALSE}
library(dbplyr)
library(dplyr, warn.conflicts = FALSE)
```

## dplyr 1.0.0 compatibility

dbplyr now supports all relevant features added in dplyr 1.0.0:

-   `across()` is now translated into individual SQL statements.

    ```{r}
    lf <- lazy_frame(g = 1, a = 1, b = 2, c = 3)
    lf %>% 
      group_by(g) %>% 
      summarise(across(everything(), mean, na.rm = TRUE))
    ```

-   `rename()` and `select()` support dplyr 1.0.0 tidyselect syntax, apart from predicate functions which can't easily work on computed queries.
    You can now use `rename_with()` to programmatically rename columns.

    ```{r}
    lf <- lazy_frame(x1 = 1, x2 = 2, x3 = 3, y1 = 4, y2 = 3)
    lf %>% select(starts_with("x") & !"x3")
    lf %>% select(ends_with("2") | ends_with("3"))
    lf %>% rename_with(toupper)
    ```

-   `relocate()` makes it easy to move columns around:

    ```{r}
    lf <- lazy_frame(x1 = 1, x2 = 2, y1 = 4, y2 = 3)
    lf %>% relocate(starts_with("y"))
    ```

-   `slice_min()`, `slice_max()`, and `slice_sample()` are now supported, and `slice_head()` and `slice_tail()` throw informative error messages (since they don't make sense for databases).

    ```{r}
    lf <- lazy_frame(g = rep(1:2, 5), x = 1:10)
    lf %>% 
      group_by(g) %>% 
      slice_min(x, prop = 0.5)

    lf %>% 
      group_by(g) %>% 
      slice_sample(x, n = 10, with_ties = TRUE)
    ```

    Note that these slices are translated to window functions, and because you can't use a window function directly inside a `WHERE` clause, they must be wrapped in a subquery.

## SQL translation

The dbplyr documentation now does a much better job of providing the details of its SQL translation.
Each backend and each major verb has a documentation page giving the basics of the translation.
This will hopefully make it much easier to learn what is and isn't supported by dbplyr.
Visit <https://dbplyr.tidyverse.org/reference/index.html> to see the new docs.

There were also many improvements to SQL generation.
Here are a few of the most important:

-   Join functions gain a `na_matches` argument that allows you to control whether or not `NA` (`NULL`) values match other `NA` values.
    The default is `"never"`, which is the usual behaviour in databases.
    You can set `na_matches = "na"` to match R's usual join behaviour.

    ```{r}
    df1 <- tibble(x = c(1, 2, NA))
    df2 <- tibble(x = c(NA, 1), y = 1:2)
    df1 %>% inner_join(df2, by = "x")

    db1 <- memdb_frame(x = c(1, 2, NA))
    db2 <- memdb_frame(x = c(NA, 1), y = 1:2)
    db1 %>% inner_join(db2, by = "x")

    db1 %>% inner_join(db2, by = "x", na_matches = "na")
    ```

    This translation is powered by the new `sql_expr_matches()` generic, because every database seems to have a slightly different way to express this idea.
    Learn more at <https://modern-sql.com/feature/is-distinct-from>.

    ```{r}
    db1 %>% inner_join(db2, by = "x") %>% show_query()
    db1 %>% inner_join(db2, by = "x", na_matches = "na") %>% show_query()
    ```

-   Subqueries no longer include an `ORDER BY` clause.
    This is not part of the formal SQL specification so has very limited support across databases.
    Now such queries generate a warning suggesting that you move your `arrange()` call later in the pipeline.

    ```{r}
    lf <- lazy_frame(g = rep(1:2, each = 5), x = sample(1:10))
    lf %>% 
      group_by(g) %>% 
      summarise(n = n()) %>% 
      arrange(desc(n)) %>% 
      filter(n > 1)
    ```

    As the warning suggests, there's one exception: `ORDER BY` is still generated if a `LIMIT` is present.
    Across databases, this tends to change which rows are returned, but not necessarily their order.

    ```{r}
    lf %>% 
      group_by(g) %>% 
      summarise(n = n()) %>% 
      arrange(desc(n)) %>% 
      head(5) %>% 
      filter(n > 1)
    ```

-   dbplyr includes built-in backends for Redshift (which only differs from PostgreSQL in a few places) and SAP HANA. These require the development versions of RPostgres and odbc respectively.

    ```{r}
    lf <- lazy_frame(x = "a", y = "b", con = simulate_redshift())
    lf %>% mutate(z = paste0(x, y))
    ```

There are a number of minor changes that affect the translation of individual functions.
Here are a few of the most important:

-   All backends now translate `n()` to `count(*)` and support `::`

    ```{r}
    lf <- lazy_frame(x = 1:10)
    lf %>% summarise(n = dplyr::n())
    ```

-   PostgreSQL gets translations for lubridate period functions:

    ```{r}
    lf <- lazy_frame(x = Sys.Date(), con = simulate_postgres())
    lf %>%
      mutate(year = x + years(1))
    ```

-   Oracle assumes version 12c is available so we can use a simpler translation for `head()` that works in more places:

    ```{r}
    lf <- lazy_frame(x = 1, con = simulate_oracle())
    lf %>% head(5)
    ```

## New logo

Thanks to the artistic talents of [Allison Horst](https://www.allisonhorst.com), dbplyr has a beautiful new logo:

<img src="dbplyr.png" width="250"/>

## Extensibility

Finally, dbplyr introduces a number of new generics to help tease apart the currently overly complicated relationship with dplyr.
This should make creating new backends much easier, but does require some changes from existing backends.
These changes should be invisible to the end user and will play out slowly over the next 12 months.
See `vignette("backend-2", package = "dbplyr")` for details.

## Acknowledgements

A big thanks to everyone who helped with this release by reporting bugs, discussing issues, and contributing code!
[\@abalter](https://github.com/abalter), [\@adhi-r](https://github.com/adhi-r), [\@batpigandme](https://github.com/batpigandme), [\@cmichaud92](https://github.com/cmichaud92), [\@Daveyr](https://github.com/Daveyr), [\@DavidPatShuiFong](https://github.com/DavidPatShuiFong), [\@elbamos](https://github.com/elbamos), [\@fh-jgutman](https://github.com/fh-jgutman), [\@gregleleu](https://github.com/gregleleu), [\@hadley](https://github.com/hadley), [\@iangow](https://github.com/iangow), [\@jkylearmstrong](https://github.com/jkylearmstrong), [\@jonkeane](https://github.com/jonkeane), [\@kmishra9](https://github.com/kmishra9), [\@kohleth](https://github.com/kohleth), [\@krlmlr](https://github.com/krlmlr), [\@lorenzwalthert](https://github.com/lorenzwalthert), [\@machow](https://github.com/machow), [\@okhoma](https://github.com/okhoma), [\@rjpat](https://github.com/rjpat), [\@rlh1994](https://github.com/rlh1994), [\@samssann](https://github.com/samssann), [\@schradj](https://github.com/schradj), [\@shosaco](https://github.com/shosaco), and [\@stiberger](https://github.com/stiberger).
