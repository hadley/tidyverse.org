---
output: hugodown::hugo_document

slug: dbplyr-2-0-0
title: dbplyr 2.0.0
date: 2020-10-12
author: Hadley Wickham
description: >
    dbplyr 2.0.0 brings dplyr 1.0.0 compatibility, numeric improvements
    to SQL translation (including new Amazon Redshift and SAP HANA 
    backends), and an improved system for extending dbplyr to work with
    other databases.
    
photo:
  url: https://unsplash.com/photos/r2A6WYI8YIg
  author: Shawn Ang

categories: [package] 
tags: [dbplyr, dplyr]
---

<!--
TODO:
* [ ] `use_tidy_thanks()`
-->

```{r, include = FALSE}
library(dplyr, warn.conflicts = FALSE)
```

We're pleased to announce the release of [dbplyr](https://dbplyr.tidyverse.org/) 2.0.0.
dbplyr is a database backend for [dplyr](https://dplyr.tidyverse.org/) that allows you to use a remote database as if it was a collection of local data frames: you write ordinary dplyr code and dbplyr translates it to SQL for you.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("dbplyr")
```

This blog post covers the major improvements in this version:

-   dplyr 1.0.0 compatibility so you can use `across()`, `relocate()`, `rename_with()`, and more with databases.

-   The most important improvements to SQL translation.

-   A snazzy new logo from [Allison Horst](https://www.allisonhorst.com).

-   An improved system for backend authors to provide new translations.

Please see the [release notes](%7B%20github_release%20%7D) for a full list of changes.

```{r setup, message = FALSE}
library(dbplyr)
library(dplyr, warn.conflicts = FALSE)
```

## dplyr 1.0.0 compatibility

dbplyr now supports all relevant features added in dplyr 1.0.0:

-   `across()` is now translated into individual SQL statements.

    ```{r}
    lf <- lazy_frame(g = 1, a = 1, b = 2, c = 3)
    lf %>% 
      group_by(g) %>% 
      summarise(across(everything(), mean, na.rm = TRUE))
    ```

-   `rename()` and `select()` support dplyr 1.0.0 tidyselect syntax, apart from predicate functions which can't easily work on computed queries.
    You can now use `rename_with()` to programmatically rename columns.

    ```{r}
    lf <- lazy_frame(x1 = 1, x2 = 2, x3 = 3, y1 = 4, y2 = 3)
    lf %>% select(starts_with("x") & !"x3")
    lf %>% select(ends_with("2") | ends_with("3"))
    lf %>% rename_with(toupper)
    ```

-   `relocate()` makes it easy to move columns around:

    ```{r}
    lf <- lazy_frame(x1 = 1, x2 = 2, y1 = 4, y2 = 3)
    lf %>% relocate(starts_with("y"))
    ```

-   `slice_min()`, `slice_max()`, and slice_sample`()` are now supported, and `slice_head()` and `slice_tail()` throw informative error messages (since they don't make sense for databases).
    These all use window functions, and because you can't use a window function directly inside a `WHERE` clause, they must generate a subquery.

    ```{r}
    lf <- lazy_frame(g = rep(1:2, 5), x = 1:10)
    lf %>% 
      group_by(g) %>% 
      slice_min(x, prop = 0.5)

    lf %>% 
      group_by(g) %>% 
      slice_sample(x, n = 10, with_ties = TRUE)
    ```

## SQL translation

You can now get much more details of the dbplyr SQL translation in the documentation.
Now each major verb and each backend get a documentation page giving the basics of the SQL translation.
This will hopefully make it much easier to learn what is and isn't supported by dbplyr.
See <https://dbplyr.tidyverse.org/reference/index.html> for details.

There were many minor improvements to SQL generation.
Here are a selection of the most important changes:

-   Join functions gains a `na_matches` argument that allows you to control whether or not `NA` (`NULL`) values match other `NA` values.
    The default is `"never"`, which is the usual behaviour in databases.
    You can set `na_matches = "na"` to match R's usual join behaviour.

    ```{r}
    df1 <- tibble(x = c(1, 2, NA))
    df2 <- tibble(x = c(NA, 1), y = 1:2)
    df1 %>% inner_join(df2, by = "x")

    db1 <- memdb_frame(x = c(1, 2, NA))
    db2 <- memdb_frame(x = c(NA, 1), y = 1:2)
    db1 %>% inner_join(db2, by = "x")

    db1 %>% inner_join(db2, by = "x", na_matches = "na")
    ```

    This translation is powered by the new `sql_expr_matches()` generic, because every database seems to have a slightly different way to express this idea.
    Learn more at <https://modern-sql.com/feature/is-distinct-from>.

    ```{r}
    db1 %>% inner_join(db2, by = "x") %>% show_query()
    db1 %>% inner_join(db2, by = "x", na_matches = "na") %>% show_query()
    ```

-   Subqueries no longer include an `ORDER BY` clause.
    This is not part of the formal SQL specification, and thus has very limited support across databases.
    Now such queries generate a warning suggesting that you move your `arrange()` call later in the pipeline.

    ```{r}
    lf <- lazy_frame(g = rep(1:2, each = 5), x = sample(1:10))
    lf %>% 
      group_by(x) %>% 
      summarise(x = mean(x, na.rm = TRUE)) %>% 
      arrange(g) %>% 
      filter(x < 1)
    ```

    As the warning suggests, there's one exception: `ORDER BY` is still generated if a `LIMIT` is present; this tends to affect the returns rows but not necessarily their order:

    ```{r}
    lf %>% 
      group_by(x) %>% 
      summarise(x = mean(x, na.rm = TRUE)) %>% 
      arrange(g) %>% 
      head(5) %>% 
      filter(x < 1)
    ```

-   dbplyr includes built-in backends for Redshift (which only differs from PostgreSQL in a few places) and SAP HANA. These require the development versions of RPostgres and odbc respectively.

    ```{r}
    lf <- lazy_frame(x = "a", y = "b", con = simulate_redshift())
    lf %>% mutate(z = paste0(x, y))
    ```

There are a number of minor changes that affect the translation of individual functions.
Here are a selection of the most important:

-   All backends now translate `n()` to `count(*)` and support `::`

    ```{r}
    lf %>% summarise(n = dplyr::n())
    ```

-   PostgreSQL gets translations for lubridate period functions:

    ```{r}
    lf <- lazy_frame(x = Sys.Date(), con = simulate_postgres())
    lf %>%
      mutate(year = x + years(1))
    ```

-   Oracle assumes 12c is available so the translation can use a simpler translation for `head()` that works in more places:

    ```{r}
    lf <- lazy_frame(x = 1, con = simulate_oracle())
    lf %>% head(5)
    ```

## New logo

Thanks to the artistic talents of [Allison Horst](https://www.allisonhorst.com), dbplyr has a beautiful new logo:

<img src="dbplyr.png" width="250"/>

## Extensibility

Finally, dbplyr introduces a number of new generics to help tease apart the currently overly complicated relationship with dplyr.
This should make creating new backends much easier, but does require some changes from existing backends.
These changes should be invisible to the end user and will play out slowly over the next 12 months.
See `vignette("backend-2", package = "dbplyr")` for details.
