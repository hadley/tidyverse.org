---
output: hugodown::hugo_document

slug: magrittr-2-0
title: magrittr 2.0 is coming soon
date: 2020-07-30
author: Lionel Henry
description: >
    A 2-3 sentence description of the post that appears on the articles page.
    This can be omitted if it would just recapitulate the title.

photo:
  url: https://unsplash.com/photos/X-NAMq6uP3Q
  author: Mike Benna

categories: [package]
tags: []
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
```

It is with unclouded exhilaration that we announce the upcoming release of [magrittr](https://magrittr.tidyverse.org/) 2.0. magrittr is the package home to the `%>%` pipe operator written by Stefan Milton Bache and used throughout the tidyverse.

With this major release, we intend to bring the behaviour of the pipe closer to the base pipe `|>` that will likely be included in a future version of R. We also fixed some longstanding issues that made the pipe problematic for programming in packages.

You can try this development version from github with:

```{r, eval = FALSE}
# install.packages("remotes")
remotes::install_github("magrittr")
```

This blog post covers the three main changes in this new version of the magrittr pipe.

```{r setup}
library(magrittr)
```


## Laziness

The main user-visible change in this release is that the pipe expressions are now evaluated lazily, only when needed.

```{r}
ignore_arguments <- function(...) "value"

stop("foo") %>% ignore_arguments()
```

This has subtle implications but should be backward compatible with existing pipelines that run without error. The main source of behaviour change is that some code that previously failed may stop failing if the latter part of the pipeline specifically handled the error.

Similarly, warnings that were previously issued might now be suppressed by a function you're piping into. That's because the following expressions are now almost completely equivalent:

```{r}
# Piped
warning("foo") %>% suppressWarnings()

# Nested
suppressWarnings(warning("foo"))
```

Thanks to this change, you will now be able to pipe into testthat error expectations, for instance:

```{r}
library(testthat) %>%
  suppressMessages()

{ 1 + "a" } %>%
  expect_error("non-numeric argument")
```


## Backtraces

The R implementation of the magrittr pipe was rather costly in terms of backtrace clutter. This made it difficult to debug errors with functions using the pipe:

```{r, eval = FALSE}
foo <- function() bar()
bar <- function() 1 %>% identity() %>% baz()
baz <- function(x) rlang::abort("oh no")

foo()
#> Error: oh no

rlang::last_trace()
#> <error/rlang_error>
#> oh no
#> Backtrace:
#>      █
#>   1. └─global::foo()
#>   2.   └─global::bar()
#>   3.     └─1 %>% identity() %>% baz()
#>   4.       ├─base::withVisible(eval(quote(`_fseq`(`_lhs`)), env, env))
#>   5.       └─base::eval(quote(`_fseq`(`_lhs`)), env, env)
#>   6.         └─base::eval(quote(`_fseq`(`_lhs`)), env, env)
#>   7.           └─`_fseq`(`_lhs`)
#>   8.             └─magrittr::freduce(value, `_function_list`)
#>   9.               ├─base::withVisible(function_list[[k]](value))
#>  10.               └─function_list[[k]](value)
#>  11.                 └─global::baz(.)
```

This clutter is now completely resolved:

```{r, eval = FALSE}
foo()
#> Error: oh no

rlang::last_trace()
#> <error/rlang_error>
#> oh no
#> Backtrace:
#>     █
#>  1. ├─global::foo()
#>  2. │ └─global::bar()
#>  3. │   └─1 %>% identity() %>% baz()
#>  4. └─global::baz(.)
```

Note that one consequence of having a lazy pipe is that the whole pipeline will shown on the call stack before any errors are thrown:

```{r, eval = FALSE}
f1 <- function(x) x
f2 <- function(x) x
f3 <- function(x) x
f4 <- function(x) x

stop("oh no") %>% f1() %>% f2() %>% f3() %>% f4()
#> Error in f1(.) : oh no

rlang::last_trace()
#> <error/rlang_error>
#> oh no
#> Backtrace:
#>     █
#>  1. ├─stop("oh no") %>% f1() %>% f2() %>% f3() %>% f4()
#>  2. ├─global::f4(.)
#>  3. ├─global::f3(.)
#>  4. ├─global::f2(.)
#>  5. └─global::f1(.)
```

The last function of the pipeline is `f4()`, so that's the first one to be run. It evaluates its argument which is provided by `f3()`, so that's the second function pushed on the stack. And so on until `f1()` needs the result of `stop("oh no")` which causes an error.


## Speed

The pipe is now written in C. This greatly improves the performance. Here is a benchmark for the old R implementation:

```{r, eval = FALSE}
bench::mark(
  `0` = f1(NULL),
  `1` = NULL %>% f1(),
  `2` = NULL %>% f1() %>% f2(),
  `3` = NULL %>% f1() %>% f2() %>% f3(),
  `4` = NULL %>% f1() %>% f2() %>% f3() %>% f4(),
)
#> + + + + + + # A tibble: 5 x 13
#>   expression     min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result
#>   <bch:expr> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>
#> 1 0            258ns   319ns  2808344.        0B      0   10000     0     3.56ms <NULL>
#> 2 1           59.4µs  68.9µs    13648.      280B     59.1  6004    26   439.91ms <NULL>
#> 3 2           82.6µs 101.6µs     9252.      280B     42.8  3894    18   420.87ms <NULL>
#> 4 3          106.4µs 124.7µs     7693.      280B     18.8  3690     9   479.64ms <NULL>
#> 5 4          130.9µs 156.1µs     6173.      280B     18.8  2956     9   478.84ms <NULL>
#> # … with 3 more variables: memory <list>, time <list>, gc <list>
```

The new C implementation is less costly per pipe expression:

```{r, eval = FALSE}
bench::mark(
  `0` = f1(NULL),
  `1` = NULL %>% f1(),
  `2` = NULL %>% f1() %>% f2(),
  `3` = NULL %>% f1() %>% f2() %>% f3(),
  `4` = NULL %>% f1() %>% f2() %>% f3() %>% f4(),
)
#>   expression      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result
#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>
#> 1 0             270ns    383ns  2240689.        0B    224.   9999     1     4.46ms <NULL>
#> 2 1            4.47µs   5.95µs   159655.        0B     79.9  9995     5     62.6ms <NULL>
#> 3 2            5.97µs    8.8µs   109534.        0B     32.9  9997     3    91.27ms <NULL>
#> 4 3            8.83µs  10.63µs    89902.        0B     27.0  9997     3    111.2ms <NULL>
#> 5 4           10.99µs  13.18µs    72330.        0B     36.2  9995     5   138.19ms <NULL>
```


## Towards a release

Though we have changed the behaviour of the pipe, none of 2600 the reverse dependencies of magrittr, purrr, tidyr, and dplyr were broken by the change. To be extra sure, we'd be grateful for any additional testing on real-life scripts with this development version.

If you're interested in the design tradeoffs involved in the creation of a pipe operator in R, see the [tradeoffs](https://magrittr.tidyverse.org/articles/tradeoffs.html) vignette. Any comments about the choices we have made are welcome.
