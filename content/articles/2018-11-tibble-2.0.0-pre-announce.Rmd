---
title: "Coming soon: tibble 2.0.0"
slug: tibble-2.0.0-pre-announce
description: >
    The upcoming tibble 2.0.0 release has internal changes relevant to package developers who depend on tibble.
date: 2018-11-21
author: Kirill MÃ¼ller, Jenny Bryan
photo:
  url: https://unsplash.com/photos/yYawh30qf28
  author: Gabriel Porras
categories: [package]
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Version 2.0.0 of the [tibble package](https://tibble.tidyverse.org) is almost ready for release. Tibbles are a modern reimagining of the data frame, keeping what time has shown to be effective, and throwing out what is not, with nicer default output too! Grab the development version with:

```r
devtools::install_github("tidyverse/tibble")
```

We're making a pre-release announcement, because some changes require the attention of maintainers of packages that import or otherwise depend on tibble.
This post describes how to adapt to the next version of tibble and is also an invitation for maintainers to provide feedback before v2.0.0 is finalized and submitted to CRAN.
This blog post is aimed at package developers and those who maintain "production" scripts or apps. A high-level overview of new user-facing features will come in a separate blog post.

## Reverse dependency checks

We ran `R CMD check` for over 3000 CRAN and Bioconductor packages that depend directly or indirectly on the tibble package and compared results obtained with the CRAN versus development version of tibble.
We notified the maintainers of affected packages and aim for a CRAN release before Christmas, just in time for [rstudio::conf](https://www.rstudio.com/conference/).

We made pull requests to implement the necessary changes in several of the most heavily downloaded packages. Based on this experience, this post highlights the problems downstream maintainers are most likely to see and how to solve them.

For the full list of changes, features, and bug fixes, please see the [release notes](https://github.com/tidyverse/tibble/tree/master/NEWS.md).

## Construction and validation

End users should use the `tibble()` function to construct tibbles.
It checks the input for consistency and makes sure that the returned tibble is valid.

Package developers, however, can also consider the low-level `new_tibble()` constructor. Use `new_tibble()` to quickly construct a tibble from a list if you are very sure that the input is well-formed (i.e., a list of vectors of equal length).
This function also supports the construction of subclasses of tibble through the `subclass` argument.

In the development version of tibble, the `new_tibble()` constructor is a more faithful implementation of the [design advice for S3 classes given in Advanced R](https://adv-r.hadley.nz/s3.html#s3-classes).
Specifically:

- `new_tibble()` is very fast again and does very little checking itself.
- The new `validate_tibble()` function is responsible for validating the structure of a tibble.

This means that the `nrow` argument to `new_tibble()` is now mandatory.
We are aware that this might be the single most disruptive change, but we think that any guesswork here would be detrimental to stability (especially in corner cases) and that this particular problem is very easy to fix.
The `nrow` argument already existed in tibble 1.4.2, so code that uses it requires no change and should continue to work.
Please be aware that `nrow` must be passed as a named argument, because it comes after the ellipsis `...` in the signature. Here are common patterns for setting the `nrow` argument:

```{r error = TRUE}
library(tibble)

x <- data.frame(a = 1)

# Old:
new_tibble(x)

# New:
new_tibble(x, nrow = nrow(x)) # if x is a data frame

nrow_x <- NROW(x[[1]]) # if x has at least one column
# nrow_x <- ... # if the number of rows is given elsewhere
new_tibble(x, nrow = nrow_x)
```

## Coercion and name repair

The tibble mentality has always been that the user is responsible for managing column names, i.e. names are not automatically munged. This remains true, but the development version of tibble is stricter about names and offers more support for name repair.

In the development version of tibble, by default, column names must exist and be unique. Some packages use `as_tibble()` internally to coerce a dysfunctionally-named object to a tibble and *then* apply proper column names. Here's a typical error and solution:

```{r error = TRUE}
library(tibble)

(m <- cov(unname(iris[-5])))

# problematic approach:
# 1. make tibble
# 2. apply nice names
x <- as_tibble(m)
colnames(x) <- letters[1:4]

# better approach that works with tibble v1.4.2 AND dev tibble:
# 1. apply nice names
# 2. make tibble
colnames(m) <- letters[1:4]
as_tibble(m)

```

If possible, we recommend applying your "good" column names prior to calling `as_tibble()`. This creates code that works with tibble 1.4.2 and the development version, which is very appealing. For good examples, see these pull requests to [drake](https://github.com/ropensci/drake/pull/586), [prophet](https://github.com/facebook/prophet/pull/739), and [broom](https://github.com/tidymodels/broom/pull/534).

It is also possible to use the new `.name_repair` argument in `tibble()` or `as_tibble()` (more below) to explicitly declare your intention around column names. This is a less appealing solution, because such code will be sensitive to the tibble version.

```{r}
# Alternative: use new `.name_repair` argument to permit dysfunctional names
m <- cov(unname(iris[-5]))
as_tibble(m, .name_repair = "minimal")

# Alternative: use new `.name_repair` argument to fix dysfunctional names
m <- cov(unname(iris[-5]))
as_tibble(m, .name_repair = "unique")
```

What is the motivation for this increased attention to column names? The tibble package is offering stronger encouragement for names where each column can be identified by name and, preferably, without having to resort to backticks. Column names that don't meet these requirements are still allowed, but the user needs to permit them explicitly.

After all, there are scenarios where problematic names should be tolerated. For example, after importing data, the user might need to inspect the data in order to determine which columns to keep. Or perhaps the column names contain data that is about to be converted to a proper variable with `gather()`.

The `tibble()` constructor and the `as_tibble()` generic now support a new `.name_repair` argument that covers most use cases:

- `"minimal"`: No name repair or checks, beyond basic existence.
- `"unique"`: Make sure names are unique and not empty.
- `"check_unique"`: (default value), no name repair, but check they are `unique`.
- `"universal"`: Make the names `unique` and syntactic.
- a function: apply custom name repair (e.g., `.name_repair = make.names` or `.name_repair = ~make.names(., unique = TRUE)` for names in the style of base R).

See ``?`name-repair``` for more details.

Packages that are in the business of making tibbles may even want to expose the `.name_repair` argument and pass it through to tibble. For example, this is the approach planned for [readxl](https://readxl.tidyverse.org), which reads rectangular data out of Excel workbooks.

## Deprecation of `validate` in `as_tibble()`

In tibble 1.4.2, `as_tibble()` has a `validate` argument, but its default behaviour value was inconsistent across different methods and there was no equivalent argument for `tibble()`. The `validate` argument is now soft-deprecated and its use will trigger a message (we intend to make this "once per session"). The `validate` argument will eventually be removed.

Here's what `validate` does in the development version of tibble:

```{r error = TRUE}
m <- cov(unname(iris[-5]))
df <- new_tibble(list(a = 5, a = 6), nrow = 1)

# errors, as it should, because columns are unnamed ... but also messages
as_tibble(m, validate = TRUE)

# errors, as it should, because names are duplicated ... but also messages
as_tibble(df, validate = TRUE)

# no error ... but still messages
as_tibble(df, validate = FALSE)
```

`validate = TRUE` is now the default behaviour, i.e. `.name_repair = "check_unique`. You can remove simply `validate = TRUE`:

```{r}
as_tibble(m)
as_tibble(df)
```

Alternatives to `validate = FALSE`, if you know that `packageVersion("tibble") >= "2.0.0"`:

```{r}
# permit non-unique names
as_tibble(df, .name_repair = "minimal")

# authorize creation of unique names
as_tibble(m, .name_repair = "unique")
```

## Deprecation of `tidy_names()` and `set_tidy_names()`

The existing `tidy_names()` and `set_tidy_names()` functions are soft-deprecated, but remain available, unchanged. In the future, they could go away or take on a new meaning, i.e. implement a different algorithm for name repair. New code should use `.name_repair` instead.

```{r}
df <- new_tibble(list(a = 5, a = 6), nrow = 1)

# these functions are soft-deprecated
tidy_names(names(df))
set_tidy_names(df)

# achieve same via `.name_repair`
as_tibble(df, .name_repair = "universal")
```

tibble's name repair strategies are currently only exposed in `tibble()` and `as_tibble()`, not (yet?) as utility functions that operate on a vector of names.

## Other changes

Intentionally assigning invalid names to a tibble via `names<-()` is generally a bad idea and this now warns (once per session).

```{r}
df <- tibble(a = 1)

names(df) <- NA
```

Coercing a vector to a tibble is no longer supported and emits a warning once per session.
It is unclear if the result should be a one-column or a one-row tibble.

```{r}
x <- 1:3
# Old:
as_tibble(x)

# New (>= 2.0.0):
enframe(x, name = NULL)

# New (legacy):
tibble(value = x)
```
