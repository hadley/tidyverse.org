---
title: 'purrr 0.3.0'
author: Lionel Henry
date: '2019-01-25'
slug: purrr-0-3-0
description: >
  purrr 0.3.0 is now on CRAN.
categories:
  - package
photo:
  url: https://unsplash.com/photos/NodtnCsLdTE
  author: Mikhail Vasilyev
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.align = 'center',
  fig.asp = 0.618, # 1 / phi
  out.width = "700px"
)

library("purrr")
```

We're excited to announce the release of [purrr](https://purrr.tidyverse.org) 0.3.0! This release polishes the consistency of the interface, introduces new `pluck()`-based functions, many improvements to mappers, and a set of tools to limit the rate at which a function is called. Find a detailed account of the changes in the [NEWS](https://github.com/tidyverse/purrr/blob/master/NEWS.md#purrr-030) file.


## Pluck assignment

`pluck()` implements a generalised form of `[[` that allow you to index deeply and flexibly into data structures. For instance, `pluck(x, "foo", 2)` is equivalent to `x[["foo"]][[2]]`. This release introduces the new functions `pluck<-`, `assign_in()` and `modify_in()` as assignment variants of `pluck()`.

To illustrate deep assignment, Let's create a nested data structure:

```{r}
x <- list(foo = list(1, 2), bar = list(3, 4))
str(x)
```

This sort of repeated structure is the kind of data where `pluck()` shines:

```{r}
pluck(x, "foo", 2)

pluck(x, "bar", 1)
```

You can now use the same syntax to modify the data:

```{r}
pluck(x, "foo", 2) <- 100
str(x)
```

`pluck<-` also has a functional form that does not modify objects in your environment, but instead returns a modified copy:

```{r}
out <- assign_in(x, list("foo", 2), 2000)

# The object is still the same as before
str(x)

# The modified data is in `out`
str(out)
```

Finally, `modify_in()` is a variant of `modify()` that only changes the pluck location with the result of applying a function:

```{r}
out <- modify_in(x, list("foo", 2), as.character)
str(out)
```


## Early termination of reduction

`reduce()` and `accumulate()` now support early termination of the reduction. To halt the computation, just return the last value wrapped in a `done()` box:

```{r}
# This computes the total sum of the input vector
reduce(1:100, ~ .x + .y)

# This stops as soon as the sum is greater than 50
reduce(1:100, ~ if (.x > 50) done(.x) else .x + .y)
```

This feature takes inspiration from the [Clojure](https://clojuredocs.org/clojure.core/reduced) language.


## Rates

Thanks to Richie Cotton (@richierocks) and Ian Lyttle (@ijlyttle), purrr gains a function operator to make a function call itself repeatedly when an error occurs.

```{r, error = TRUE}
counter <- 0

f <- function(...) {
  if (counter < 2) {
    counter <<- counter + 1
    stop("tilt!")
  }
  "result"
}

f()
```

If the function is wrapped with `insistently()`, it will try a few times before giving up:

```{r}
# Reset counter
counter <- 0

f2 <- insistently(f)
f2()
```

Another rate limiting function is `slowly()`. While `insistently()` loops by itself, `slowly()` is designed to be used in your own loops, for instance in a map iteration:

```{r}
f <- function(...) print(Sys.time())

walk(1:3, f)

walk(1:3, slowly(f))
```

`slowly()` uses a constant rate by default while `insistently()` uses a backoff rate. The rate limiting can be configured with optional jitter via `rate_backoff()` and `rate_delay()`, which implement exponential backoff rate and constant rate respectively.

```{r}
walk(1:3, slowly(f, rate_backoff(max_times = Inf)))
```


## `map_if()`... or else?

If you like using `map_if()`, perhaps you'll find the new `.else` argument useful. `.else` is a function applied to elements for which the predicate is `FALSE`:

```{r}
map_if(iris, is.numeric, mean, .else = nlevels)
```


## Strictness

### Stricter predicate checking

purrr now checks the results of your predicate functions, which must now consistently return `TRUE` or `FALSE`. We no longer offer support for `NA` or for boolish numeric values (R normally interprets 0 as `FALSE` and all other values as `TRUE`). The purpose of this change is to detect errors earlier with a more relevant error messages.

```{r, error = TRUE}
keep(c(1, NA, 3), ~ . %% 2 == 0)
```


### Stricter pluck()

Thanks to Daniel Barnett (@daniel-barnett on Github), `pluck()` now has a stricter cousin `chuck()`. Whereas `pluck()` is very permissive regarding non-existing locations and returns `NULL` in these cases, `chuck()` fails consistently with informative messages:

```{r, error = TRUE}
pluck(list(1), "foo")

chuck(list(1), "foo")
```


## New `map_at()` features

Colin Fay (@ColinFay) has added support for tidyselect expressions to `map_at()` and other `_at` mappers. This brings the interface of these functions closer to scoped functions from the dplyr package, such as `dplyr::mutate_at()`. Note that `vars()` is currently not reexported from purrr, so you need to use `dplyr::vars()` or `ggplot2::vars()` for the time being.

```{r}
suppressMessages(library("dplyr"))

x <- list(
  foo = 1:5,
  bar = 6:10,
  baz = 11:15
)

map_at(x, vars(starts_with("b")), mean)
```

`map_at()` now also supports negative selections:

```{r}
map_at(x, -2, `*`, 1000)
```


## Consistency of behaviour

A lot of effort went towards more consistent behaviour in purrr. An important improvement is that `modify()` is now a wrapper around `[[<-` rather than `[<-`. This should make it directly compatible with a larger set of vector classes.

Thanks to the work of Mikko Marttila (@mikmart), `pmap()` and `pwalk()` do a better job of preserving S3 classes. `pluck()` also works better with S3 objects. In the next version of purrr, we plan to use the in-development vctrs package to provide more principled and predictable vector operations.

Other small improvements in consistency of behaviour are:

* `modify_depth()` now operates at the atomic level as well.
* `map()` and `modify()` now work with calls and pairlists.


## Consistency of the interface

### Direction of application

The direction of application is now specified the same way across purrr functions. `reduce()`, `compose()` and `detect()` now have a `.dir` parameter that can take the value `"forward"` or `"backward"`. This terminology should be less ambiguous than "left" and "right":

```{r, eval = FALSE}
reduce(1:4, `-`, .dir = "backward")

compose(foo, bar, .dir = "forward")

detect(1:5, ~ . %% 2 == 0, .dir = "backward")
```

Note that the backward version of `reduce()` (called right-reduce in the literature) applies the reduced function in a slightly different way that is more consistent with how this operation

Consequently, the `_right` variants such as `reduce_right()` have been soft-deprecated, as well as the `.right` argument of `detect()` and `detect_index()`.


### partial()

`partial()` has been rewritten to be a simple wrapper around `call_modify()` and `eval_tidy()` from the rlang package. Consequently, the `.env`, `.lazy` and `.first` arguments are soft-deprecated and replaced by a flexible syntax.

To control the timing of evaluation, unquote the partialised arguments that should be evaluated only once when the function is created. The non-unquoted arguments are evaluated at each invokation of the function:

```{r}
my_list <- partial(list, lazy = rnorm(3), eager = !!rnorm(3))

my_list()

my_list()
```

You can also control the position of the future arguments by passing an empty `... = ` parameter. This syntax is powered by `rlang::call_modify()` to control where the position of dots in a function call:

```{r}
my_list <- partial(list, 1, ... = , 2)

my_list()

my_list("foo")
```


### `exec()` replaces `invoke()`

We are retiring `invoke()` and `invoke_map()` in favour of `exec()`. Retirement means that we'll keep these functions indefinitely in the package, but we won't add features or recommend using them.

We are now favouring `exec()`, which uses the tidy dots syntax for passing lists of arguments:

```{r}
# Before:
invoke(mean, list(na.rm = TRUE), x = 1:10)

# After
exec(mean, 1:10, !!!list(na.rm = TRUE))
```


### Filling the missing parts

* purrr 0.3.0 introduces `accumulate2()`, `modify2()` and `imodify()` variants.

* By popular request, `at_depth()` is back as `map_depth()`. Unlike `modify_depth()` which preserves the class structure of the input tree, this variant only returns trees made of lists of lists, coercing vectors if needed.


## Thanks!

Thanks to all the contributors for this release!

  [&#xFF20;ArtemSokolov](https://github.com/ArtemSokolov), [&#xFF20;batpigandme](https://github.com/batpigandme), [&#xFF20;bbrewington](https://github.com/bbrewington), [&#xFF20;billdenney](https://github.com/billdenney), [&#xFF20;cderv](https://github.com/cderv), [&#xFF20;cfhammill](https://github.com/cfhammill), [&#xFF20;ColinFay](https://github.com/ColinFay), [&#xFF20;dan-reznik](https://github.com/dan-reznik), [&#xFF20;daniel-barnett](https://github.com/daniel-barnett), [&#xFF20;danilinares](https://github.com/danilinares), [&#xFF20;drtjc](https://github.com/drtjc), [&#xFF20;egnha](https://github.com/egnha), [&#xFF20;Eluvias](https://github.com/Eluvias), [&#xFF20;flying-sheep](https://github.com/flying-sheep), [&#xFF20;gergness](https://github.com/gergness), [&#xFF20;gvwilson](https://github.com/gvwilson), [&#xFF20;hadley](https://github.com/hadley), [&#xFF20;hammer](https://github.com/hammer), [&#xFF20;ijlyttle](https://github.com/ijlyttle), [&#xFF20;ilarischeinin](https://github.com/ilarischeinin), [&#xFF20;IndrajeetPatil](https://github.com/IndrajeetPatil), [&#xFF20;ISPritchin](https://github.com/ISPritchin), [&#xFF20;jameslairdsmith](https://github.com/jameslairdsmith), [&#xFF20;jameslamb](https://github.com/jameslamb), [&#xFF20;jrnold](https://github.com/jrnold), [&#xFF20;kcf-jackson](https://github.com/kcf-jackson), [&#xFF20;leungi](https://github.com/leungi), [&#xFF20;lionel-](https://github.com/lionel-), [&#xFF20;loladze](https://github.com/loladze), [&#xFF20;maxheld83](https://github.com/maxheld83), [&#xFF20;mikmart](https://github.com/mikmart), [&#xFF20;MilesMcBain](https://github.com/MilesMcBain), [&#xFF20;moodymudskipper](https://github.com/moodymudskipper), [&#xFF20;mrstlee](https://github.com/mrstlee), [&#xFF20;namelessjon](https://github.com/namelessjon), [&#xFF20;r-cheologist](https://github.com/r-cheologist), [&#xFF20;randomgambit](https://github.com/randomgambit), [&#xFF20;rmflight](https://github.com/rmflight), [&#xFF20;roumail](https://github.com/roumail), [&#xFF20;Ryo-N7](https://github.com/Ryo-N7), [&#xFF20;serina-robinson](https://github.com/serina-robinson), [&#xFF20;skaltman](https://github.com/skaltman), [&#xFF20;suraggupta](https://github.com/suraggupta), [&#xFF20;thays42](https://github.com/thays42), [&#xFF20;tyluRp](https://github.com/tyluRp), [&#xFF20;tzakharko](https://github.com/tzakharko), [&#xFF20;VincentGuyader](https://github.com/VincentGuyader), [&#xFF20;wlandau](https://github.com/wlandau), [&#xFF20;wmayner](https://github.com/wmayner), [&#xFF20;yanxianl](https://github.com/yanxianl), [&#xFF20;yutannihilation](https://github.com/yutannihilation), and [&#xFF20;yysh12](https://github.com/yysh12)
