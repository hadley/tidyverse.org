---
title: dplyr 0.8.0 release candidate
author: Romain François
date: '2018-10-23'
slug: dplyr-0-8-0-release-candidate
description: > 
  dplyr 0.8.0 release candidate
categories:
  - package
tags:
  - dplyr
  - tidyverse
---



<div id="tidy-grouping-structure" class="section level1">
<h1>Tidy grouping structure</h1>
<p>Previous versions of <code>dplyr</code> used a messy set of attributes in grouped
tibbles to keep track of the groups and their indices. This has been
re-organized into a tibble that can be accessed with the new
<code>group_data()</code> function.</p>
<pre class="r"><code>iris %&gt;% 
  group_by(Species) %&gt;% 
  group_data()
#&gt; # A tibble: 3 x 2
#&gt;   Species    .rows     
#&gt;   &lt;fct&gt;      &lt;list&gt;    
#&gt; 1 setosa     &lt;int [50]&gt;
#&gt; 2 versicolor &lt;int [50]&gt;
#&gt; 3 virginica  &lt;int [50]&gt;</code></pre>
<p>The first columns of that tibble describe the groups in terms of the
grouping variables, and the last column (always called <code>.rows</code>)
is a list of integer vectors identifying the (one-based) indices of
each group.</p>
<p>The related function <code>group_rows()</code> gives just that last column.</p>
<pre class="r"><code>iris %&gt;% 
  group_by(Species) %&gt;% 
  group_rows()
#&gt; [[1]]
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
#&gt; [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
#&gt; [47] 47 48 49 50
#&gt; 
#&gt; [[2]]
#&gt;  [1]  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67
#&gt; [18]  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84
#&gt; [35]  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100
#&gt; 
#&gt; [[3]]
#&gt;  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117
#&gt; [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134
#&gt; [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150</code></pre>
</div>
<div id="new-grouping-algorithm" class="section level1">
<h1>New grouping algorithm</h1>
<p>The algorithm behind <code>group_by()</code> has been redesigned to better respect factors.
In previous versions of <code>dplyr</code> groups were created to only match the observed data,
which was potentially losing groups when factors are involved.</p>
<p>The new algorithm respects the levels of the factors that are involved in the
grouping, by creating groups even if there is no data in that group.</p>
<pre class="r"><code>df &lt;- tibble(
  x = c(1,1,2,2), 
  f = factor(c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;), levels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
)
df %&gt;% 
  group_by(f) %&gt;% 
  group_data()
#&gt; # A tibble: 3 x 2
#&gt;   f     .rows    
#&gt;   &lt;fct&gt; &lt;list&gt;   
#&gt; 1 a     &lt;int [2]&gt;
#&gt; 2 b     &lt;int [2]&gt;
#&gt; 3 c     &lt;int [0]&gt;</code></pre>
<p>Where previous versions of <code>dplyr</code> would have created only two groups (for levels <code>a</code> and <code>b</code>),
it now creates one group per level, and the group related to the level <code>c</code> just happens to be
empty.</p>
<p>Groups are still made to match the data on other variables:</p>
<pre class="r"><code>df %&gt;% 
  group_by(x) %&gt;% 
  group_data()
#&gt; # A tibble: 2 x 2
#&gt;       x .rows    
#&gt;   &lt;dbl&gt; &lt;list&gt;   
#&gt; 1     1 &lt;int [2]&gt;
#&gt; 2     2 &lt;int [2]&gt;</code></pre>
<p>Consider this tibble using a mix of factors and non factors</p>
<pre class="r"><code>df &lt;- tibble(
  f1 = factor(c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;), levels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)), 
  f2 = factor(c(&quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), levels = c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)), 
  x  = c(1, 1, 1, 2, 2), 
  y  = 1:5
)</code></pre>
<p>If we group by the factors <code>f1</code> and <code>f2</code>, we get 9 groups</p>
<pre><code># 9 groups : 3 x 3
df %&gt;% 
  group_by(f1, f2) %&gt;% 
  group_data()</code></pre>
<p>When factors and non factors are involved in the grouping, the number of
groups depends on the order. At each level of grouping, factors are always expanded
to one group per level, but non factors only create groups based on observed data.</p>
<pre><code># 3 groups
df %&gt;% 
  group_by(f1, x) %&gt;% 
  group_data()</code></pre>
<p>In this example, we group by <code>f1</code> then <code>x</code>. At the first layer, grouping on <code>f1</code> creates
two groups. Each of these grouops is then subdivided based on the values of the second
variable <code>x</code>. Since <code>x</code> is always 1 when <code>f1</code> is <code>a</code> the group is not
further divided.</p>
<p>The last group, associated with the level <code>c</code> of the factor <code>f1</code> is empty, and
consequently has no values for the vector <code>x</code>. In that case, <code>group_by()</code> uses
<code>NA</code>.</p>
<pre><code># 6 groups
df %&gt;% 
  group_by(x, f1) %&gt;% 
  group_data()</code></pre>
<p>When we group by <code>x</code> then <code>f1</code> we initially split the data according to <code>x</code> which
gives 2 groups. Each of these two groups is then further divided in 3 groups,
i.e. one for each level of <code>f1</code>.</p>
</div>
<div id="performance" class="section level1">
<h1>Performance</h1>
<p>TODO:
- unwind protect</p>
</div>
<div id="less-surprising-hybrid-evaluation" class="section level1">
<h1>Less surprising hybrid evaluation</h1>
<p>Hybrid evaluation has been entirely redesigned to be more predictable
and less surprising.</p>
<p>When we evaluate an expression in <code>mutate()</code> or <code>summarise()</code>, the hybrid system
first assert that it can entirely evaluate the expression independently with native code,
if it can it does.</p>
<pre class="r"><code>iris %&gt;% 
  group_by(Species) %&gt;% 
  summarise(Petal.Length = mean(Petal.Length))
#&gt; # A tibble: 3 x 2
#&gt;   Species    Petal.Length
#&gt;   &lt;fct&gt;             &lt;dbl&gt;
#&gt; 1 setosa             1.46
#&gt; 2 versicolor         4.26
#&gt; 3 virginica          5.55</code></pre>
<p>The expression <code>mean(Petal.Length)</code> is handled by native code because there is an hybrid
internal version of <code>mean</code>, and its first argument is a column of the data, and the type of
that column can be treated by the internal function.</p>
<p>If the expression can not be evaluated completely, it gets evaluated using R standard
evaluation rules in a special environment that makes the columns available (the data mask).</p>
<pre class="r"><code>iris %&gt;% 
  group_by(Species) %&gt;% 
  summarise(Petal.Length = sum(Petal.Length) / n())
#&gt; # A tibble: 3 x 2
#&gt;   Species    Petal.Length
#&gt;   &lt;fct&gt;             &lt;dbl&gt;
#&gt; 1 setosa             1.46
#&gt; 2 versicolor         4.26
#&gt; 3 virginica          5.55</code></pre>
<p>The expression <code>sum(Petal.Length) / n()</code> is not recognized, so evaluation goes through the
standard path. For each group, the subset of <code>Petal.Length</code> is extracted, then the R function <code>sum</code>
is called on it and this is divided by the result of calling the <code>n()</code> function from <code>dplyr</code>.</p>
<p>Previous versions of <code>dplyr</code> attempted to partially evaluate <code>sum(Petal.Length) / n()</code> with the
hybrid evaluator, because <code>sum(Petal.Length)</code> and <code>n()</code> can both independently be handled. This was
making it hard to obey R semantics because R is too flexible.</p>
</div>
<div id="nest_by-nest_join" class="section level1">
<h1>nest_by, nest_join</h1>
<p>TODO</p>
</div>
<div id="colwise-verbs" class="section level1">
<h1>colwise verbs</h1>
<p>TODO</p>
</div>
