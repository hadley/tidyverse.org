---
title: tibble 3.0.0
slug: tibble-3.0.0
description: >
    tibble 3.0.0 is on CRAN now! Tibbles are a modern reimagining of the data frame, keeping what time has shown to be effective, and throwing out what is not, with nicer default output too! This article describes the latest major release and provides an outlook on further developments
date: 2020-03-30
author: Kirill MÃ¼ller
photo:
  url: https://twitter.com/skyetetra/status/1160012260456062977
  author: Jacqueline Nolis
categories: [package, programming]
---


```{r setup, include = FALSE}
library(tidyverse)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", error = TRUE)

options(crayon.enabled = TRUE)
```

```{r setup-hooks, comment="", results="asis", echo=FALSE}
old_hooks <- fansi::set_knit_hooks(
  knitr::knit_hooks,
  which = c("output", "error"),
  proc.fun = function(x, class) {
    x <- unlist(strsplit(x, "\n", fixed = TRUE))
    x <- gsub("[.][.][.]", ".\u200b.\u200b.", x)
    fansi::html_code_block(fansi::sgr_to_html(fansi::html_esc(x)), class = class)
  }
)
```


Version 3.0.0 of the *tibble* package is on CRAN now. Tibbles are a modern reimagining of the data frame, keeping what time has shown to be effective, and throwing out what is not, with nicer default output too! Grab the latest version with:

```r
install.packages("tibble")
```

Tibble now fully embraces vctrs, using it under the hood for its subsetting and subset assignment ("subassignment") operations.
Accessing and updating rows and columns is now based on a rock-solid framework and works consistently for all types of columns, including list, data frame, and 
matrix columns.
We believe that the changes will ultimately lead to better and safer code.

This major release required quite some preparation, including a [new vignette](https://www.tidyverse.org/articles/2018/11/tibble-2.0.0-pre-announce/) that described the behavior of subsetting operations and the reasoning behind it.
Due to the nature of the changes, about 60 CRAN packages were failing with our release candidate.
Thanks to the maintainers of downstream packages who were very helpful in making this upgrade a smooth experience.

In this blog post, I focus on a few user- and programmer-related changes, and give an outlook over future development:

- How to ensure that an object can be part of a tibble
- Pitfalls with type conversion
- Safe error handling
- Formatting

For a complete overview please see the [release notes](https://github.com/tidyverse/tibble/releases/tag/v2.0.0).

Use the [issue tracker](https://github.com/tidyverse/tibble/issues) to submit bugs or suggest ideas, your contributions are always welcome.


## What can be part of a tibble?

Tibbles and data frames are collections of columns, each is a vector, all have the same length.
Neat.

What is a vector?
What is its length?

The new [vctrs package](https://vctrs.r-lib.org) is dedicated to answering these, surprisingly tricky, questions.
The `vctrs::vec_is()` function decides if an object is a vector.
This is important, because some objects are inherently scalar and cannot be added as a column to a data frame.

Environments, functions, and other "special" types of objects are clearly non-vectors.
It is far less obvious for lists, in particular if they have a `"class"` attribute:

```{r compare-list}
model <- lm(y ~ x, data.frame(x = 1:3, y = 2:4), model = FALSE)
is.list(model)
length(model)
time <- as.POSIXlt(Sys.time())
is.list(time)
length(time)
length(unclass(time))
```

By relying on `vctrs::vec_is()`, the `tibble::tibble()` function and others can give an early error if used with an inherent scalar:

```{r tibble}
library(tibble)
tibble(model)
tibble(time)
```

The new `tibble_row()` function reverses this: inherent scalars are wrapped in lists:

```{r tibble}
tibble_row(model)
tibble_row(time)
tibble_row(time = rep(time, 2))
```

For the `"POSIXlt"` class, this is handled by vctrs internally.
For your own class, there are two ways to ensure that a list object is treated as a vector:

- Add an explicit `"list"` to its classes
- Implement a `vctrs::vec_proxy()` method

```{r list}
x <- structure(list(1), class = c("foo", "list"))
vctrs::vec_is(x)

y <- structure(list(1), class = "bar")
vctrs::vec_is(y)

vec_proxy.bar <- function(x, ...) x
vctrs::vec_is(y)
```

If you have implemented a vector class (list or not), please add it to my [Awesome vectors](https://github.com/krlmlr/awesome-vctrs#readme) list or file an issue.

## Pitfalls with type conversion

- vctrs decides which types are coercible
- clean error message when coercion fails
- updating NA columns

## Classed conditions

- all errors classed
- how to catch
- error classes experimental, subject to change

## Outlook: formatting moves to pillar

- full control over all parts of the tibble
- extensibility for formatting columns
- consolidate formatting code
- printing of data frames

## Acknowledgments
