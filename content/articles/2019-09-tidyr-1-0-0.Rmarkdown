---
title: tidyr 1.0.0
author: Hadley Wickham
date: '2019-09-03'
slug: tidyr-1-0-0
categories:
  - package
tags:
  - tidyr
photo:
  url: https://unsplash.com/photos/0yL6nXhn0pI
  author: Victor Garcia
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(
  tibble.print_min = 6, 
  tibble.print_max = 6
)
```

I'm very excited to announce that [tidyr 1.0.0](https://tidyr.tidyverse.org) is now available on CRAN! tidyr provides a set of tools for transforming data frames to and from [tidy data](https://tidyr.tidyverse.org/dev/articles/tidy-data.html), where each variable is a column and each observation is a row. Tidy data is a convention for matching the semantics and structure of your data that makes using the rest of the tidyverse (and many other R packages) much easier.

Install it with:

```{r, eval = FALSE}
install.packages("tidyr")
```

As you might guess from the version number, this is a major release, and the 1.0.0 moniker indicates that I'm finally happy with the overall interface of the tidyr. This has been a long time coming: it's five years since the first tidyr release, nine years since the first reshape2 release, and fourteen years since the first reshape release! 

This blog post summarises the four major changes to the package:

* New `pivot_longer()` and `pivot_wider()` functions for pivotting, or 
  reshaping, data which replace `spread()` and `gather()`. The new functions
  are substantially more powerful thanks to ideas from the data.table and 
  cdata packages, and I'm confident that you'll find them easier to use and 
  remember than their predeccessors thanks to careful consideration of their
  interfaces.
  
* New functions for **rectangling**, converting deeply nested lists into tidy
  rectangles. `unnest_auto()`, `unnest_longer()`, `unnest_wider()`, and
  `hoist()` make it significantly easier to wrangle JSON into tidy
  data frames.
  
* Interface changes to `nest()` and `unnest()` to match emerging consensus
  for interface design across the tidyverse. I have also discovered that
  `nest()`ing can be decomposed in `pack()`ing and `chop()`ing.
  
* New `expand_grid()`, a variant of `base::expand.grid()`. This is a useful 
  function, but also serves as a good venue to talk about the important role
  that [vctrs](http://vctrs.r-lib.org/) is playing behind the scenes. You 
  shouldn't ever need to know about vctrs, but it brings improvements to 
  consistency and performance. 

As well as implementing the new features, I've spent considerable time on the documentation, including four major new vignettes:

* [`vignette("in-packages")`](https://tidyr.tidyverse.org/dev/articles/in-packages.html)
  provides best practices for using tidyr inside
  another package, and provides detailed advice on working with multiple 
  versions of tidyr if an interface change has affected your package.

* [`vignette("pivot")`](https://tidyr.tidyverse.org/dev/articles/pivot.html), 
  [`vignette("rectangle")`](https://tidyr.tidyverse.org/dev/articles/rectangle.html), 
  and [`vignette("nest")`](https://tidyr.tidyverse.org/dev/articles/nest.html) 
  provide detailed documentation and case studies of pivotting, rectangling, 
  and nesting respectively.

You can see a complete list of all the other minor bug fixes and improvements in the [release notes](https://tidyr.tidyverse.org/dev/news/index.html#tidyr-1-0-0).

```{r setup, message = FALSE}
library(tidyr)
library(dplyr)
```

## Pivoting

New [`pivot_longer()`](https://tidyr.tidyverse.org/dev/reference/pivot_longer.html) and [`pivot_wider()`](https://tidyr.tidyverse.org/dev/reference/pivot_wider.html) provide modern alternatives to `spread()` and `gather()`. They have been carefully redesigned to be easier to learn and remember, and include many new features. `spread()` and `gather()` won't go away, but they've been marked as retired which means that they're no longer under active development.

The best place to learn about `pivot_longer()` and `pivot_wider()` is [`vignette("pivot")`](https://tidyr.tidyverse.org/dev/articles/pivot.html), or by watching my presentation to the [Vienna R users group](https://www.youtube.com/watch?v=D48JHU4llkk). Here I'll quickly show off a few of the coolest new features:

*   `pivot_longer()` can now separate column names into multiple variables in 
    single step. For example, take the `who` dataset which has column names
    that look like `new_{diagonsis}_{gender}{age}`:
    
    ```{r}
    names(who)
    ```
    
    You can now tease apart the variable names in a single step by supplying
    a vector of variable names to `names_to` and a regular expression to
    `names_pattern` (simpler cases might only need `names_sep`):

    ```{r}
    who %>% pivot_longer(
      cols = new_sp_m014:newrel_f65,
      names_to = c("diagnosis", "gender", "age"), 
      names_pattern = "new_?(.*)_(.)(.*)",
      values_to = "count"
    )
    ```

*   `pivot_longer()` can now work with rows that contain multiple observations
    (this feature was inspired by data.table's `dcast()` method). For example,
    take the base `anscombe` dataset. Each row consists of four pairs of
    `x` and `y` measurements:
    
    ```{r}
    head(anscombe)
    ```
  
    We can now tidy this in a single step by using the special `.value` 
    variable name:
    
    ```{r}
    anscombe %>% 
      pivot_longer(
        everything(),
        names_to = c(".value", "set"),
        names_pattern = "(.)(.)"
      ) %>% 
      as_tibble()
    ```
    
*   `pivot_wider()` can now do simple aggregations (`reshape2::dcast()` fans 
    rejoice!). For example, take the base `warpbreaks` dataset (converted to a 
    tibble to print more compactly):    

    ```{r}
    warpbreaks <- warpbreaks %>% as_tibble() %>% select(wool, tension, breaks)
    warpbreaks
    ```
    
    This is a designed experiment with nine replicates for every combination of
    `wool` (`A` and `B`) and `tension` (`L`, `M`, `H`). If we attempt to pivot 
    the levels of `wool` into the columns we get a warning and the output
    contains list-columns:
    
    ```{r}
    warpbreaks %>% pivot_wider(names_from = wool, values_from = breaks)
    ```

    You can now summarise the duplicates with the `values_fn` argument:
    
    ```{r}
    warpbreaks %>% 
      pivot_wider(
        names_from = wool, 
        values_from = breaks,
        values_fn = list(breaks = mean)
      )
    ```

Learn the full details and see many more examples in [`vignette("pivot")`](http://tidyr.tidyverse.org/dev/articles/pivot.html).

## Rectangling

Rectangling is the art and craft of taking a deeply nested list (often sourced from wild caught JSON or XML) and taming it into a tidy data set of rows and columns. There are four new functions in tidyr 1.0.0 that make rectangling much easier:

* `unnest_longer()` takes each element of a list-column and makes a new row.
* `unnest_wider()` takes each element of a list-column and makes a new column.
* `unnest_auto()` guesses whether you want `unnest_longer()` or `unnest_wider()`.
* `hoist()` is similar to `unnest_wider()` but only plucks out selected
  components, and can reach down multiple levels.

For example, take this small sample of `repurrrsive::got_chars`. It contains data about three Game of Thrones characters:

```{r}
characters <- list(
  list(
    name = "Theon Greyjoy",
    aliases = c("Prince of Fools", "Theon Turncloak", "Theon Kinslayer"),
    alive = TRUE
  ),
  list(
    name = "Tyrion Lannister",
    aliases = c("The Imp", "Halfman", "Giant of Lannister"),
    alive = TRUE
  ),
  list(
    name = "Arys Oakheart",
    alive = FALSE
  )
)
```

To work with the new tidyr rectangling tools, we first put the list into a data frame, creating a list-column:

```{r}
got <- tibble(character = characters)
got
```

We can then use `unnest_wider()` to make each element of that list into a column:

```{r}
got %>% 
  unnest_wider(character)
```

Then `unnest_longer()` to turn each alias into its own row:

```{r}
got %>% 
  unnest_wider(character) %>% 
  unnest_longer(aliases)
```

Even more conveniently, you can use `unnest_auto()` to guess which direction a list column should be unnested in. Here it yields the same results as above, and the messages tell you why:

```{r, results = FALSE}
got %>% 
  unnest_auto(character) %>% 
  unnest_auto(aliases)
```

Alternatively, you can use `hoist()` to reach deeply into a data structure and just put out the pieces you need:

```{r}
got %>% hoist(character, 
  name = "name",
  alias = list("aliases", 1),
  alive = "alive"
)
```

This replaces our previous recommendation to use `dplyr::mutate()` and `purrr::map()` together:

```{r, results = FALSE}
got %>% mutate(
  name = purrr::map_chr(character, "name"),
  alias = purrr::map_chr(character, list("aliases", 1), .default = NA),
  alive = purrr::map_lgl(character, "alive")
)
```

Learn more in [`vignette("rectangle")`](http://tidyr.tidyverse.org/dev/articles/rectangle.html).

## Nesting

`nest()` and `unnest()` have been updated with new interfaces that are more closely aligned to evolving tidyverse conventions. The biggest change is to their operation with multiple columns: `df %>% unnest(x, y, z)` becomes `df %>% unnest(c(x, y, z))` and `df %>% nest(x, y, z)` becomes `df %>% nest(data = c(x, y, z))`
  
I have done my best to ensure that common uses of `nest()` and `unnest()` will continue to work, generating an informative warning telling you precisely how you need to update your code. Please [file an issue](https://github.com/tidyverse/tidyr/issues/new) if I've missed an important use case.

Behind the scenes, I discovered that nesting (and unnesting) can be decomposed into the combination of two simpler operations:

* `pack()` and `unpack()` pack and unpack multiple columns into a single data 
  frame columns. 
  
* `chop()` and `unchop()` chop up rows into sets of list-columns. 

<p><img src="/images/tidyr-1-0-0/nest-pack-chop.png" width="480" height="352" /></p>


This is primarily of theoretical interest, but it considerably simplified implementation, and you may occassionally find the underlying functions useful when working with exotic data structures.

## `expand_grid()`

[`expand_grid()`](https://tidyr.tidyverse.org/dev/reference/expand_grid.html) completes the existing family of `expand()`, `nesting()`, and `crossing()` with a low-level function that works with vectors:

```{r}
expand_grid(
  x = 1:3,
  y = letters[1:3],
  z = LETTERS[1:3]
)
```

Compared to existing base function `expand.grid()`, `expand_grid()`:

* Varies the first element slowest (not fastest).
* Never converts strings to factors and doesn't add any additional attributes.
* Returns a tibble, not a data frame.
* Can expand any generalised vector, including data frames.

The last feature is quite powerful:

```{r}
students <- tribble(
  ~ school, ~ student,
  "A",      "John",
  "A",      "Mary",
  "A",      "Susan",
  "B",      "John"
)
expand_grid(students, semester = 1:2)
```

This is made possible because underneath the covers tidyr now uses [vctrs](https://vctrs.r-lib.org). vctrs is primarily of interest to package developers but I wanted to talk about it briefly here because I've been having a lot of fun working with it. It's hard to concisely describe what vctrs is, but one part of it is carefully defining what a "vector" is, and provding a set of useful functions that work on all types of vctrs with zero special cases. It turns out that thinking of a data frame as a vector of rows (as opposed to a vector of columns like R usually does) is a suprisingly useful generalisation, and something you can expect to see in more places in the tidyverse in the future. 

Note that when data frame inputs are unnamed they're automatically unpacked into individual columns in the output. If you want to produce a single data frame column, name that output:

```{r}
expand_grid(student = students, semester = 1:2)
```

Data frame columns aren't particularly useful yet, but they provide powerful building blocks for future extensions. For example, we expect a future version of dplyr will support data frame columns as a way for `mutate()` and `summarise()` to create multiple new columns from a single function call.
